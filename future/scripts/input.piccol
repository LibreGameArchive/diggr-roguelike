

px Void->UInt :- get->Player->UInt(\x).
py Void->UInt :- get->Player->UInt(\y).  

def { x:UInt y:UInt dx:Int dy:Int } XyPair;
def [a:UInt b:UInt c:Int d:Int];
def [a:UInt b:Bool];
def [a:UInt b:Int];

go UInt->OutState :- OutState{ticks=(<: \v + 1u :>) done=false dead=false}.

regen [UInt Bool]->OutState :- \a go->OutState {regenerate=\b}.


add XyPair->XyPair :- XyPair{ x=\x y=\y dx=(<:int(\x)+\dx:>) dy=(<:int(\y)+\dy:>) }.

walkable XyPair->Bool :-
  [ \x \y \dx \dy ] dg_neighbors_linked->Bool ? 
  [ (\dx to->UInt) (\dy to->UInt) ] dg_render_is_walkblock->Bool $not ? true;
  false
.

move [Int Int]->Void :-
  XyPair{ x=(px->UInt) y=(py->UInt) dx=\a dy=\b } add->XyPair->Void( 
    \\ walkable->Bool ? 
      [ \x \y (\dx to->UInt) (\dy to->UInt) ]->Void (
          get->Player {x=\c y=\d} set
          [ \a \b \c \d ] move_player))
.

add [UInt Int]->UInt :-
  <: int(\a) + \b :> ->UInt( <: \v >= 0 :> ? <: uint(\v) :>; 0u ).

dlevel Void->UInt :- get->Dungeon->UInt(\level).

get Void->FeatFlags :- [ (px->UInt) (py->UInt) ] get->FeatFlags.

descend Void->Bool :-
  get->FeatFlags->Int(<: \stairs > 0 :> ? \stairs)->Bool(
     'You climb down the hole.' msg
     [ (dlevel->UInt) \v ] add->UInt->Bool( get->Dungeon {level=\v} set true )
  )
;
  'You can\'t descend, there is no hole here.' msg
  false
.


/***/

<:: enums(literals)
    ident_here :- ident &''.    
    integer_here :- integer &''.
    enum :- spaces ident_here @' Void->Int :- ' spaces integer_here @'.' spaces.
    enums :- enum enums.
    enums :- .
::>

<:: switch(literals)
  ident_here :- ident &''.
  sym_here :- sym &''.
  case :- @'[\\v (' spaces ident_here spaces @'->Int)] $eq ?' sym_here spaces @';'.
  cases :- case cases.
  cases :- .
  switch :- @'->Sym(' cases @' fail)'.
::>


<:[enums] 

  key_up    14
  key_left  15 
  key_right 16
  key_down  17

  key_pageup   10
  key_pagedown 11
  key_end      12
  key_home     13

  key_kp1 35
  key_kp2 36
  key_kp3 37
  key_kp4 38
  key_kp5 39
  key_kp6 40
  key_kp7 41
  key_kp8 42
  key_kp9 43

  key_f9  58
  key_f10 59
  key_f11 60
  key_f12 61

:>

remap InState->InState :- 
  \\ { c=(\vk
  <:[switch]
    key_left     'h'
    key_down     'j'
    key_up       'k'
    key_right    'l'
    key_home     'y'
    key_pageup   'u'
    key_end      'b'
    key_pagedown 'n'
    key_kp4      'h'
    key_kp6      'l'
    key_kp8      'k'
    key_kp2      'j'
    key_kp7      'y'
    key_kp9      'u'
    key_kp1      'b'
    key_kp3      'n'
   :>
   )}
  ; \\ .


/***** *** *****/


handle_input InState->OutState :-

  \\ remap->InState->OutState (
    <:[case] \c :

       'S' ? OutState{ticks=\ticks done=true dead=false} ;
       'Q' ? OutState{ticks=\ticks done=true dead=true} ;

       '.' ? \ticks go->OutState ;

       'h' ? [-1  0] move \ticks go->OutState ;
       'j' ? [ 0  1] move \ticks go->OutState ;
       'k' ? [ 0 -1] move \ticks go->OutState ;
       'l' ? [ 1  0] move \ticks go->OutState ;
       'y' ? [-1 -1] move \ticks go->OutState ;
       'u' ? [ 1 -1] move \ticks go->OutState ;
       'b' ? [-1  1] move \ticks go->OutState ;
       'n' ? [ 1  1] move \ticks go->OutState ;

       '>' ? [\ticks (descend->Bool)] regen->OutState;
    :>
    OutState{ticks=\ticks done=false dead=false} 
  )
.


drawing_context Void->[UInt UInt] :-
  get->Player->[UInt UInt]( '*** ' print \x print ' ' print \y print '\n' print [\x \y]).

